%
% Libelf by Example
%
% Copyright (c) 2006-2009 Joseph Koshy.  All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%    notice, this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
%
% This software is provided by Joseph Koshy ``as is'' and
% any express or implied warranties, including, but not limited to, the
% implied warranties of merchantability and fitness for a particular purpose
% are disclaimed.  in no event shall Joseph Koshy be liable
% for any direct, indirect, incidental, special, exemplary, or consequential
% damages (including, but not limited to, procurement of substitute goods
% or services; loss of use, data, or profits; or business interruption)
% however caused and on any theory of liability, whether in contract, strict
% liability, or tort (including negligence or otherwise) arising in any way
% out of the use of this software, even if advised of the possibility of
% such damage.
%
% $Id$
%
\documentclass[a4paper]{report}

\usepackage{color}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{varioref}

\newcommand{\function}[1]{\texttt{#1}()}
\newcommand{\library}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\texttt{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\parameter}[1]{\texttt{#1}}
\newcommand{\tool}[1]{\textbf{#1}}
\newcommand{\type}[1]{\texttt{#1}}
\newcommand{\co}[1]{\framebox{\textbf{\color{blue}#1}}}

\begin{document}
\lstset{language=C,basicstyle=\small,escapechar=@,float}

\begin{abstract}
This tutorial introduces the \library{libelf} library being developed
at the \href{http://elftoolchain.sourceforge.net/}{ElfToolChain}
project on \href{sourceforge.net}{SourceForge.Net}.  It shows how this
library can be used to create tools that can manipulate ELF objects
for native and non-native architectures.

The ELF(3)/GELF(3) API set is discussed, as is handling of ar(1)
archives.  The ELF format is discussed to the extent needed to
understand the use of the ELF(3) library.

Knowledge of the C programming language is a pre-requisite.
\end{abstract}

\chapter{Introduction}
ELF \index{ELF+definition} stands for Extensible Linking Format.  It
is a format for use by compilers, linkers, loaders and other tools
that manipulate object code.

The ELF specification was released to the public in 1990 as an
``\href{http://www.x86.org/ftp/manuals/tools/elf.pdf}{open standard}''
by a group of vendors.  As a result of its ready availability it has
been widely adopted in the industry and is now the most popular object
file format in use in the open-source world.  The ELF standard
supports 32 and 64 bit architectures of both big and little-endian
kinds, and supports features like cross-compilation, dynamic shared
libraries.  ELF also supports the special compilation needs of the C++
language.  In the open-source operating system commnunity, FreeBSD
switched to using ELF as its object format in FreeBSD 3.0 (October
1998).
% TODO XXX fill in Linux and NetBSD history.

The \library{libelf} library provides an API set (ELF(3) and
GELF(3) for application writers to read and write ELF
objects with.  The library eases the task of writing cross-tools
that can run on one machine architecture and manipulate ELF
objects for another.

\section*{Rationale for this tutorial}
The ELF(3) and GELF(3) API set is large, with over 80 callable
functions.  So the task of getting started with the library can appear
daunting at first glance.  This tutorial has been written to provide a
gentle introduction to the API set.

\section*{Target Audience}
This tutorial would be of interest to developers wanting to create ELF
processing tools using the \library{libelf} library.

\section{Tutorial Overview}
The tutorial covers the following:

\begin{itemize}
\item The basics of the ELF format (as much as is needed to understand
  how to use the API set); how the ELF format structures the contents
  of executables, relocatables and shared objects.
\item How to get started building applications that use the
  \library{libelf} library.
\item The basic abstractions offered by the ELF(3) and GELF(3) API
  set---how the ELF library abstracts out the ELF class and endianness
  of an ELF object and allows the application to work with a native
  representation while the library translates to and from the desired
  target representation behind the scenes.
\item How to use the APIs in the library to look inside an ELF object and examine its Executable Header, Program
  Header Table and its component sections.
\item How to create a new ELF object using the ELF library.
\item An introduction to the class-independent GELF(3) interfaces, and when and where to use them
 instead of the class-dependent functions in the ELF(3) API set.
\item How to process \tool{ar} archives using the facilities provided by the library.
\end{itemize}

\section{Article Structure}
One of the goals of this tutorial is to illustrate how to write code
using \library{libelf}.  So we will jump right into working code.  As
we progress through the examples, we introduce the concepts necessary
to understand what is happening ``behind the scenes.''

Chapter \vref{chap.getting-started} covers the basics involved in
getting started with the ELF(3) library---how to compile and link an
application that uses \library{libelf}.  We look at the way a working
version number is established by an application, how a handle to ELF
objects are obtained, and how error messages from the ELF library are
reported.  APIs covered include \function{elf\_begin},
\function{elf\_end}, \function{elf\_errmsg}, \function{elf\_errno},
\function{elf\_kind} and \function{elf\_version}.

Chapter \vref{chap.peering-inside} shows how an application can look
inside an ELF object and understand its basic structure.  Along the
way we will examine the way the ELF objects are laid out.  Other key
concepts examined are the notions of ``file representation''
\index{representation+file} and ``memory representation''
\index{representation+memory} of ELF data types.  New APIs covered
include \function{elf\_getident}, \function{elf\_getphnum},
\function{elf\_getshnum}, \function{elf\_getshstrndx},
\function{gelf\_getehdr} and \function{gelf\_getclass}.

Chapter \vref{chap.elf-phdr} describes the ELF Program Header Table and
shows how an application can retrieve this table from an ELF object.
The \function{gelf\_getphdr} API is introduced in this chapter.

Chapter \vref{chap.elf-sections} then looks at how data is stored in
ELF sections.  An application that looks at ELF sections is examined.
The \type{Elf\_Scn} and \type{Elf\_Data} data types used by the
library are examined in detail.  APIs covered include
\function{elf\_getscn}, \function{elf\_getdata},
\function{elf\_nextscn}, \function{elf\_strptr},
and \function{gelf\_getshdr}.

Chapter \vref{chap.creating-elf} looks at how we create ELF objects.
We cover the rules in ordering of the individual API calls when
creating ELF objects.  We look at the library's object layout rules
and how an application can choose to override these.  APIs covered
include \function{elf\_fill}, \function{elf32\_getshdr},
\function{elf32\_newehdr}, \function{elf32\_newphdr},
\function{elf\_flagphdr}, \function{elf\_ndxscn},
\function{elf\_newdata}, \function{elf\_newscn}, and
\function{elf\_update}.

The \library{libelf} library also assists applications that need read
\tool{ar} archives.  Chapter \vref{chap.ar} in the tutorial covers how
to use the ELF(3) library to handle archives.  This chapter covers the
use of the \function{elf\_getarhdr}, \function{elf\_getarsym},
\function{elf\_next} and \function{elf\_rand} functions.

Chapter \vref{chap.conclusion} ends the tutorial with suggestions for
further reading.

\chapter{Getting Started}\label{chap.getting-started}

Let us dive in first and get a taste of programming with
\library{libelf}.

Our first program (Program 1, listing \vref{src.prog.1}) will open a
filename presented to it on its command line and retrieve the file
type recognized by the ELF library.

This example is covers the basics involved in using \library{libelf};
how to compile a program using \library{libelf}, how to initialize the
library, how to report errors, and how to wind up.

\lstinputlisting[caption=Program 1,label=src.prog.1]{prog1.txt}

\begin{description}
  \item[\co{1}] The functions and dataypes that make up the ELF(3) API
    are declared in \filename{libelf.h}.  This file must be included
    in every application that desires to use the \library{libelf}
    library.

  \item[\co{2}] The ELF(3) library uses an opaque type \type{Elf} as a
    handle for the ELF object being processed.

  \item[\co{4}] Before the functions in the library can be invoked, an
    application must indicate to the library the version of the ELF
    specification it is expecting to use.  This is done by the call to
    \function{elf\_version}.

    A call to \function{elf\_version} is mandatory before other
    functions in the ELF library can be invoked.

    There are three version numbers that come into play when an
    application is manipulating an ELF object.

    \begin{itemize}
    \item First, there is the version of the ELF specification ($v_1$)
      that the application understands.
    \item Second, we have the ELF version associated with the ELF
      object being processed ($v_2$).
    \item Third, we have the version(s) known to the \library{libelf}
      library ($v_1$ and $v_2$).
    \end{itemize}

    \label{fig.versions} \includegraphics[scale=.9]{fig-versions}

    In the figure \vpageref{fig.versions} the application expects to
    work with ELF specification version ($v_1$). The ELF object file
    conforms to ELF specification version ($v_2$).  The library
    understands both version $v_1$ and $v_2$ of ELF semantics and so
    is able to mediate between the application and the ELF object.

    In practice though, the ELF version hasn't changed since
    inception, so the current version (\constant{EV\_CURRENT}) is 1.

  \item[\co{5}] The \function{elf\_begin} function takes an open file
    descriptor and converts it an \type{Elf} handle according to the
    command specified.

    The second parameter to \function{elf\_begin} can be one of
    \constant{ELF\_C\_READ} for opening an ELF object for reading,
    \constant{ELF\_C\_WRITE} for creating a new ELF object, or
    \constant{ELF\_C\_RDWR} for opening an ELF object for updates.
    The mode with which file descriptor \parameter{fd} was opened with
    must be consistent with the this parameter.

    The third parameter to \function{elf\_begin} is only used when
    processing \tool{ar} archives.  We will look at \tool{ar} archive
    processing in chapter \vref{chap.ar}.

  \item[\co{6}] When the ELF library encounters an error, it records
    an error number in an internal location.  This error number may be
    retrieved using the \function{elf\_errno} function.

    The \function{elf\_errmsg} function returns a human readable
    string describing the error number passed in.  As a programming
    convenience, a value of -1 denotes the current error number.

  \item[\co{3} \co{7}] The ELF library can operate on \tool{ar}
    archives and ELF objects.  The function \function{elf\_kind}
    returns the kind of object associated with an \type{Elf} handle.
    The return value of the \function{elf\_kind} function is one of
    the values defined by the \type{Elf\_Kind} enumeration.

    The \type{Elf\_Kind} type is defined in \filename{libelf.h}.

  \item[\co{8}] When you are done with a handle, it is good practice
    to release its resources using the \function{elf\_end} function.
\end{description}

Now it is time to get something running.

Save the listing in listing \vref{src.prog.1} to file
\filename{prog1.c} and then compile and run it as shown in listing
\vref{scr.prog.1}.

\begin{lstlisting}[language=sh,caption=Compiling and running prog1,label=scr.prog.1]
% cc -o prog1 prog1.c -lelf @\co{1}@
% ./prog1 prog1 @\co{2}@
prog1: elf object
% ./prog1 /usr/lib/libc.a @\co{3}@
/usr/lib/libc.a: ar(1) archive
\end{lstlisting}

\begin{description}
  \item[\co{1}] The \parameter{-lelf} option to the \tool{cc} comand
    informs it to link \tool{prog1} against the \library{libelf}
    library.
  \item[\co{2}] We invoke \tool{prog1} on itself, and it recognizes
    its own executable as ELF object.  All is well.
  \item[\co{3}] Here we see that \tool{prog1} recognizes an \tool{ar}
    archive correctly.
\end{description}

Congratulations!  You have created your first ELF handling program
using \library{libelf}.

In the next chapter we will look deeper into the ELF format and learn
how to pick an ELF object apart into its component pieces.

\chapter{Peering Inside}\label{chap.peering-inside}
\chapter{Examining the Program Header Table}\label{chap.elf-phdr}
\chapter{Looking at Sections}\label{chap.elf-sections}
\chapter{Creating new ELF objects}\label{chap.creating-elf}
\chapter{Processing ar(1) archives}\label{chap.ar}
\chapter{Conclusion}\label{chap.conclusion}
\end{document}

